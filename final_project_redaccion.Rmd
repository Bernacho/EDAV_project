---
editor_options:
  chunk_output_type: console
output:
  html_document: default
---

<style type="text/css">
.main-container {
  max-width: 1400px;
  margin-left: auto;
  margin-right: auto;
}

body{ /* Normal  */
      font-size: 18px;
  }

/* Headers */
h2,h5{
  font-size: 30pt;}

  code.r{
  font-size: 14px;
}

pre {
  font-size: 14px
}

</style>



<p style="text-align: center;"><a href="https://fontmeme.com/friends-tv-series-font/"><img src="https://fontmeme.com/permalink/191211/c38580a1d391d18ad5079b34977bb940.png" alt="friends-tv-series-font" border="0"></a></p>

<p style="text-align: center;"><a href="https://fontmeme.com/friends-tv-series-font/"><img src="https://fontmeme.com/permalink/191211/f0004919fd179262830b98cd6e18e52b.png" alt="friends-tv-series-font" border="0"></a></p>


\
\


<p style="text-align: center;"><a href="https://fontmeme.com/friends-tv-series-font/"><img src="https://fontmeme.com/permalink/191211/f7d3118720f664779fee95240eaf0c16.png" alt="friends-tv-series-font" border="0"></a></p>


```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
library(rvest)
library(robotstxt)
library(tidyverse)
library(Hmisc)
library(textmineR)
library(extracat)
library(GGally)
library(htmltools)
library(textmineR)
library(ggrepel)
library(cluster)
library(igraph, quietly = TRUE, warn.conflicts = FALSE, verbose = FALSE)
library(visNetwork)
library(ggplot2)
library(plotly)
```

\
<center>
![](https://media.giphy.com/media/yrsaQdz7sVems/giphy.gif)
</center>

The code for this analysis is published in a public [Git Hub repository](https://github.com/Bernacho/EDAV_project).

## **I. Introduction**

### ***i) Friends iconic sitcom***

**Friends** is an American situation comedy, created by David Crane and Marta Kauffman, which aired on NBC from September 22, 1994, to May 6, 2004, lasting ten seasons. With an ensemble cast starring **Jennifer Aniston (Rachel)**, **Courteney Cox (Monica)**, **Lisa Kudrow (Phoebe)**, **Matt LeBlanc (Joey)**, **Matthew Perry (Chandler)** and **David Schwimmer (Ross)**.


The show revolved around six friends in their 20s and 30s who lived in Manhattan, New York City. Rachel Green, a sheltered but friendly woman, flees her wedding day and her rich yet unfulfilling life, and finds childhood friend Monica Geller, a tightly-wound but caring chef. After Rachel becomes a waitress at coffee house Central Perk, she and Monica become roommates at Monica's apartment located directly above Central Perk, and Rachel joins Monica's group of single people in their mid-20s: her previous roommate Phoebe Buffay, an eccentric, innocent masseuse; her neighbor across the hall Joey Tribbiani, a dim-witted yet loyal struggling actor and womanizer; Joey's roommate Chandler Bing, a sarcastic, self-deprecating IT manager; and her older brother and Chandler's college roommate Ross Geller, a sweet-natured but insecure paleontologist.



Friends received positive reviews throughout its run and became one of the most popular sitcoms of its time. The series won many awards and was nominated for 63 Primetime Emmy Awards. The series was also very successful in the ratings, consistently ranking in the top ten in the final primetime ratings. Friends has made a large cultural impact, and has become an the model to follow for sitcoms.

### ***ii) Motivation & Questions***

As teenagers at the beginning of the century, we were heavily influenced by the Friends phenomenon and became huge fans of the sitcom. We decided to work on this project to challenge through a data analysis our preconceptions of the show and discover hiden insights. The questions that guide our quantitative assessment are the following:

* Can we categorize by importance all the appearing characters of the sitcom? This question at first glance could seem simple but under the assumption that we do not possess any previous knowledge of the sitcom and considering that over the ten seasons more than 800 characters appeared in the show, the analysis represents a challenge.

* Can we identify and quantify the interactions between the main and secondary characters? What would be an appropriate way to quantify and visualize these relationships?

* Which are the most recurrent topics through the seasons and episodes of the show? And how the thematic of the show evolved over its ten seasons? Can we extract this information through the dialogues of the show?

* Can we determine the contribution of each character to the popularity of the sitcom? Does the participation of each character influence the viewer's preferences?

### ***iii) R Libraries, Machine Learning techniques & Other resources***

We have use the next R libraries for the development of this project :

* For data extraction and manipulation: [`dplyr`](https://www.rdocumentation.org/packages/dplyr){target="_blank"}, [`rvest`](https://www.rdocumentation.org/packages/rvest/versions/0.3.5){target="_blank"}, [`robotstxt`](https://www.rdocumentation.org/packages/robotstxt/versions/0.6.2){target="_blank"},[`base`](https://www.rdocumentation.org/packages/base/versions/3.6.2){target="_blank"}, [`Hmisc`](https://www.rdocumentation.org/packages/Hmisc/versions/4.3-0){target="_blank"}


* For data visualization: [`ggplot2`](https://www.rdocumentation.org/packages/ggplot2/versions/3.2.1){target="_blank"}, [`ggthemes`](https://www.rdocumentation.org/packages/ggthemes/versions/3.5.0){target="_blank"}, [`ggrepel`](https://www.rdocumentation.org/packages/ggrepel/versions/0.8.1){target="_blank"}, [`visNetwork`](https://www.rdocumentation.org/packages/visNetwork/versions/2.0.9){target="_blank"}, [`d3`](https://d3js.org/){target="_blank"}

* Furthermore, for run some of the analysis and visualizations we have used some Machine Learning (ML) techniques and other statistical tools such as: Kmeans analysis([`cluster`](https://www.rdocumentation.org/packages/cluster/versions/2.1.0){target="_blank"}), Graph and network analysis([`igraph`](https://www.rdocumentation.org/packages/igraph/versions/1.2.4.2){target="_blank"}), Topic analysis([`textmineR`](https://www.rdocumentation.org/packages/textmineR/versions/3.0.4){target="_blank"}, [`stopwords`](https://www.rdocumentation.org/packages/stopwords/versions/1.0){target="_blank"})


## **II. Data sources**

### ***i) Primary sources***

The primary data sources that we used for our project and that we consider that have an adequate quality are:

   * Transcripts: For the transcripts, we used an open resource built by fans of the sitcom and that has been compiled in a Github repository. The repository contains all the dialogues of the characters for the 231 episodes of the tv-show. The data is organized in Html documents.. The data can be accessed via: https://fangj.github.io/friends/. If you want to see how de transcripts are originally presented [please click here](https://fangj.github.io/friends/season/0101.html).

   * Ratings: For the ratings, we have used the IMDb Datasets which is available for access to customers for personal and non-commercial use.  The data is structured in seven compressed CSV files that contain general information of the show (genre, start year, end year, episode duration, etc.), and specific information of each episode (title, rating, characters, crew, etc.). A relevant characteristic of the database is that it is refreshed daily. We have made the consultation of the Data on November 10, 20199. The data can be accessed via: https://datasets.imdbws.com/


### ***ii) Data quality and challenges***

   * IMDb Dataset:

      + The first obstacle that we faced with the IMDb datasets was the size of the data sets, some of them have millions of rows with the information of Tv-series, shorts, movies, documentaries, and other entertainment formats. It was impossible to store them in our Github.

      + The second obstacle was to track, which was the data corresponding to our case of study. For example, we searched in the dataset only by name 'Friends' we found 178 results of TV-series or movies called 'Friends'. It was necessary to understand and do some research on the years of beginning and end of the series to refine the search.

      +  Another obstacle was that the ID for TV-series across the seven IMDb datasets was not uniform. For example, in the dataset corresponding to the titles of the TV-series, the ID to identify the show is named "tconst", while on the dataset that where we can get the ID of the episode the name correspond to the ID of the episode, and the ID for the TV-series is called "parentTconst". These errors were identified through the exploration of the datasets.

   * Transcipt Dataset:

      +  The main obstacle of the dialogue dataset is that not all the HTML files share the same format. We have overcome this difficulty by incorporating special cases in our scraping code that took into account the special cases that we have detected.

      + The second difficulty that we have experienced in the dialogue dataset is the cleaning of the dialogues itself. We tried to standardize as most as possible the content of the dialogues, by identifying different names for the same character, common typos and regular expressions that could hinder our analysis.

    You can follow the scraping code that lead to the folowing data frame by looking into "frieds.Rmd" file in the Git Hub repository.

```{r eval=FALSE}
url <- "https://fangj.github.io/friends/"
paths_allowed(url)
```

```{r echo=FALSE, eval=FALSE}
html <- read_html(url)
episodes_list <- html %>% html_nodes("li")  %>% html_nodes("a")
link <- episodes_list %>% html_attr("href")
long_name <- episodes_list %>% html_text
episodes_df <- data.frame(long_name,link) %>%
  mutate(numbers = str_extract(long_name,"(\\d+-\\d+)|\\d+") ) %>%
  mutate(season=ifelse(str_length(str_match(numbers,"\\d+"))==3, substr(numbers,0,1),substr(numbers,0,2) ) ) %>%
  mutate(number=str_replace(str_replace(numbers,season,""), paste("-",season,sep = "")  ,"-") ) %>%
  mutate(name = trimws(str_replace(long_name,"(\\d+-\\d+)|\\d+","")) )%>%
  mutate(link = paste(url,link,sep="")) %>%
  mutate(id=paste(season,":",number))

episodes_df <- episodes_df[colnames(episodes_df)!="numbers"]
```

```{r echo=FALSE}
read_dialogues <- function(link,ep_id) {
  html <- read_html(link)
  #### Special case for episode 9 : 15
  if (ep_id == "9 : 15"){
    df_1 <- read.csv("data/episode_9_15.csv")
    df_2 <- df_1 %>%
      mutate(rows2= trimws(str_replace(rows,"\\(([^\\)]+)\\)"," ") )) %>%
      mutate(is_scene = ifelse(substr(rows2,0,1)=="[",1,0))
  }else{
      if(length(html %>% html_nodes("p,font p"))<10 ){
        rows <- html %>% html_nodes("font[size='3']") %>%
          gsub(pattern = '<.*?>', replacement = "|")
        if(length(rows)==0){
          rows <- html %>%
              gsub(pattern = '<br\\s*/?>', replacement = "|")
        }

        df_1 <-data.frame()
        for (i in 1:length(rows)) {
          rows_2 <- strsplit(rows[i],split="[|]")
          df_temp <- data.frame(rows_2)
          names(df_temp) <- c("rows")
          df_1 <- rbind(df_1, df_temp)
        }

        df_2 <- df_1 %>%
          mutate(rows2= trimws(rows)) %>%
          mutate(rows2 = str_replace_all(rows2, "[\n]" , " ")) %>%
          mutate(rows2 = str_replace_all(rows2, "<b>" , " ")) %>%
           mutate(rows2 = str_replace_all(rows2, "</b>" , " ")) %>%
          mutate(is_scene = ifelse(substr(rows2,0,1)=="[" | substr(rows2,0,1)=="(",1,0)) %>%
          mutate(rows2= trimws(ifelse(is_scene==1,rows2,str_replace(rows2,"\\[([^\\)]+)\\]"," "))   ))

    }else{
        rows <- html %>% html_nodes("p,font p") %>% html_text()
        df_1 <- data.frame(rows)
        df_2 <- df_1 %>%
      mutate(rows2= trimws(str_replace(rows,"\\(([^\\)]+)\\)"," ") )) %>%
      mutate(is_scene = ifelse(substr(rows2,0,1)=="[",1,0))
    }
  }

  df_2$split <- str_locate(df_2[,"rows2"],  "\\w+:|\\w+.\\w+:|\\w+.\\s\\w+:" )[,2]

  df_3 <- df_2 %>%
    mutate(character=ifelse(is.na(split),"",toupper(trimws(substr(rows2,0,split - 1 ))))) %>%
    mutate(line=ifelse(is.na(split),"",trimws(substr(rows2,split + 1,1000000)))) %>%
    mutate(episode_id = ep_id) %>%
    mutate(line=trimws(str_replace_all(line,"\\(([^\\)]+)\\)"," ")) ) %>%
    mutate(line=trimws(str_replace_all(line,"[\r\n]"," ")) ) %>%
    mutate(line=trimws(str_replace_all(line,'[\"]'," ")) ) %>%
    mutate(line=trimws(str_replace_all(line,"\\s+"," ")) ) %>%
    filter(character != "WRITTEN BY")


  df_4 <- data.frame(df_3, scene=cumsum(df_3$is_scene))

  df_5 <- df_4 %>%
    filter(rows2!="",!is_scene,!is.na(character),character!="")

  df_5$line_num <- seq.int(nrow(df_5))
  df_6<- df_5 %>%
    dplyr::select(c("episode_id","line_num","scene",'character','line'))

  return(df_6)
}

```

```{r echo=FALSE, eval=FALSE}
dialogues <- data.frame()
for (i in 1:nrow(df)) {
  n <- read_dialogues(df[i,"link"],df[i,"id"])
  dialogues <- rbind(dialogues, n)
}
head(dialogues)
```

```{r echo=FALSE}
# To speed up the process we just read the data file instead of scraping
dialogues <- read_csv("data/friends_scraping.csv")
episodes_df <- read_csv("data/friends_episodes.csv")
head(dialogues)
```


## **III. Data transformation**

### ***i) Building a Metabase***

 * Step 1:
      + Step 1.1: After scraping the dialogues data we had to do some data cleaning and transformation to create a data frame with the name of the character, dialogue line, scene, episode and words count.

      First we added a word count to dialogues.

```{r echo=FALSE}
dialogues <- dialogues %>%
  mutate(words = sapply(strsplit(line, " "), length))

head(dialogues %>% select(line,words))
```

We can see that some episodes where put together in the same file:
```{r echo=FALSE}
 unique(filter(dialogues, grepl("-",episode_id))$episode_id)
```

Now we split those episodes into two different ones:

```{r echo=FALSE}
dialogues <- dialogues %>%
  mutate(episode_id = if_else(episode_id == "2 : 12-13" & scene < 36,"2 : 12",episode_id)) %>%
  mutate(episode_id = if_else(episode_id == "2 : 12-13" & scene >= 36,"2 : 13",episode_id)) %>%
  mutate(episode_id = if_else(episode_id == "6 : 15-16" & scene < 15,"6 : 15",episode_id)) %>%
  mutate(episode_id = if_else(episode_id == "6 : 15-16" & scene >= 15,"6 : 16",episode_id)) %>%
  mutate(episode_id = if_else(episode_id == "9 : 23-24" & scene < 16,"9 : 23",episode_id)) %>%
  mutate(episode_id = if_else(episode_id == "9 : 23-24" & scene >= 16,"9 : 24",episode_id)) %>%
  mutate(episode_id = if_else(episode_id == "10 : 17-18" ,"10 : 17",episode_id))

episodes_df <- rbind(episodes_df,c("","","2","12","The Superbowl (part 1)","2 : 12"))
episodes_df <- rbind(episodes_df,c("","","2","13","The Superbowl (part 2)","2 : 13"))

episodes_df <- rbind(episodes_df,c("","","6","15","That Could Have Been (part 1)","6 : 15"))
episodes_df <- rbind(episodes_df,c("","","6","16","That Could Have Been (part 2)","6 : 16"))

episodes_df <- rbind(episodes_df,c("","","9","23","In Barbados (part 1)","9 : 23"))
episodes_df <- rbind(episodes_df,c("","","9","24","In Barbados (part 2)","9 : 24"))

episodes_df <- rbind(episodes_df,c("","","10","17","The Last One","10 : 17"))
```

For more clarity, we will add season and episode columns.

```{r echo=FALSE}
dialogues <- dialogues %>%
  mutate(season =  trimws(str_extract(episode_id,".+\\:"))) %>%
  mutate(episode =trimws(str_extract(episode_id,"\\:.+")))

dialogues <- dialogues %>%
  mutate(season =  as.integer( trimws(str_sub(season, end=-2)))) %>%
  mutate(episode = as.integer(trimws(str_sub(episode, start=2))))
```

Now we have to correct some character names that had typos and we removed some lines that the scraping code catched that are not dialogues.

```{r echo=FALSE}
dialogues <- dialogues %>%
  mutate(character = if_else(character == "RACH" ,"RACHEL", character)) %>%
  mutate(character = if_else(character == "MNCA" ,"MONICA", character)) %>%
  mutate(character = if_else(character == "CHAN" ,"CHANDLER", character)) %>%
  mutate(character = if_else(character == "PHOE" ,"PHOEBE", character))

dialogues <- filter(dialogues, dialogues$character!="TELEPLAY BY" &
                    dialogues$character!="PART I WRITTEN BY" &
                    dialogues$character!="{TRANSCRIBER'S NOTE" &
                    dialogues$character!="STORY BY" &
                    dialogues$character!="{TRANSCIBER<U+0092>S NOTE"&
                    dialogues$character!="TRANSCRIBED BY"&
                    dialogues$character!="STAGE MANAGER"&
                    dialogues$character!="DIRECTED BY"&
                    dialogues$character!='<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 TRANSITIONAL//EN" "HTTP'&
                    dialogues$character!="{NOTE"&
                    dialogues$character!="CREDITS [SCENE"&
                    dialogues$character!="ORIGINALLY WRITTEN BY MICHAEL CURTIS AND GREG MALINS"&
                    dialogues$character!="(THE COMMERCIAL"&
                    dialogues$character!="AIRED"&
                    dialogues$character!="{TRANSCIBER\u0092S NOTE"&
                    dialogues$character!="{TRANSCRIBER\u0092S NOTE")

head(dialogues)
```

More data transformation will be used and explained in each of the Results subsections.


      + Step 1.2: Extract, decompress and save as dataframes. Tha 3 tables of IMDb that we have used in our analysis are those that allowed us to extract the information related to the rating of each episode.

```{r include=FALSE}
load(file = "data/dfratings.RData")
load(file = "data/dfepisode.RData")
```
*title.ratings.tsv.gz*
```{r echo=FALSE}
str(dfratings)
```

*title.episode.tsv.gz*
```{r echo=FALSE}
str(dfepisode)
```

   * Step 2: Join the 3 data frames of IMDb to create an intermediate dataframe.Notice that this dat frame will contain the average rating of IMDb per episode. Furthermore, we created a suitable key to join this dataframe with the dataframe of that contain the dialogues.

```{r include=FALSE}

IMDbEpisodes=inner_join(data.frame("parentTconst" = c("tt0108778"), "titleType" = c("tvSeries"), "primaryTitle" = c("Friends")) ,dfepisode, by=c("parentTconst"="parentTconst"))

# Get the rating for each episode

IMDbRatings=left_join(IMDbEpisodes,dfratings, by=c("tconst"="tconst"))

rm(dfratings, dfepisode)


#Create key to join IMDb information with dialogues data base

IMDbRatings=IMDbRatings %>%
  mutate(episode_id=paste(as.character(IMDbRatings$seasonNumber), ":",
                          ifelse(as.numeric(as.character(IMDbRatings$episodeNumber))>=10,
                                 as.character(IMDbRatings$episodeNumber),
                                 paste0(as.character("0"),as.character(IMDbRatings$episodeNumber)))))
```

```{r echo=FALSE}
str(IMDbRatings)
```

   * Step 3: With a Left-Join we created the Metabase that had as primary dataframe the dialogues and as secondary dataframe the ratimgs from IMDb.

```{r include=FALSE}
dialogues=inner_join(dialogues,IMDbRatings[,c(1,4,7,8,9)], by= c("episode_id"="episode_id"))
```

```{r echo=FALSE}
str(dialogues)
```


## **IV. Missing values**

To search for missing values we look at the number of missing values per columns in **dialouges**.
```{r echo=FALSE}
colSums(is.na(dialogues))
```

There appear to be some missing values for line column. We will use **visna** from **extracats** library to see the pattern of missing values.

```{r echo=FALSE}
visna(dialogues)
```

This missing values are due to a different formats in the Git Hub page used for web scraping. For example, lines like "Paolo: (something in Italian)" render a NA line because the scraping code removes everything between parenthesis.

We decided to fill those missing values with "". By doing so we will keep the register for those characters dialogue.

```{r echo=FALSE}
dialogues <- dialogues %>%
  mutate(words = if_else(is.na(line) , 0, as.double(words))) %>%
  mutate(line = if_else(is.na(line) ,"", line))
```


## **V. Results**

### ***Labeling the main and secondary characters and its participation***


* The first big question that we want to explore is the categorization by importance by the participation of the characters? As we have previously mentioned this question seems to be naive, however, if we assume that we do not have any previous knowledge of the sitcom and considering that over the ten seasons more than 800 characters appeared in the show, the analysis is far from being a naive exercise.

To answer this question we have used the unsupervised Machine Learning technique of Kmean. Its objective s to label the data based on certain characteristics, in this case, we used the number of words, lines, and scenes. To accomplish this task we have used the libraries  [`cluster`](https://www.rdocumentation.org/packages/cluster/versions/2.1.0){target="_blank"}, and [`base`](https://www.rdocumentation.org/packages/base/versions/3.6.2){target="_blank"}. Moreover, we have established established a priori the desired number of labels tha we wanted for our data, for practicity terms we decides to set the size of the groups or kmeans.

```{r include=FALSE}


DF_Character_Episode=dialogues%>%
  group_by(episode, season, scene, character, episode_id)%>%
  summarise(num_lines= n(), totwords=sum(words,na.rm = T), avgRating=mean(averageRating,na.rm = T) )%>%
  arrange(scene ,-num_lines, -totwords)%>%
  group_by(character, episode, season, episode_id)%>%
  summarise(Total_scene= n(), Total_lines=sum(num_lines,na.rm = T),Tot_words=sum(totwords,na.rm = T),Avg_Rating=mean(avgRating,na.rm = T) )%>%
  arrange(-Total_scene ,-Total_lines, -Tot_words)

DF_Character=dialogues%>%
  group_by(episode, season, scene, character, episode_id)%>%
  summarise(num_lines= n(), totwords=sum(words,na.rm = T))%>%
  arrange(scene ,-num_lines, -totwords)%>%
  group_by(character)%>%
  summarise(Total_scene= n(), Total_lines=sum(num_lines,na.rm = T),Total_words=sum(totwords,na.rm = T))%>%
  arrange(-Total_scene ,-Total_lines, -Total_words)


set.seed(100)
ClusterCharacter=kmeans(DF_Character[,2:4], 3, nstart = 100)
vcluster=seq.int(1,3,1)
Centers=arrange(data.frame(ClusterCharacter$centers, vcluster), -Total_scene, -Total_lines, -Total_words)
DF_kmeans=cbind(DF_Character, as.data.frame(ClusterCharacter$cluster))
colnames(DF_kmeans)[5]=c('Cluster')

DF_kmeans=DF_kmeans%>%mutate(Group=ifelse(DF_kmeans$Cluster==Centers[1,4],"Main",ifelse(DF_kmeans$Cluster==Centers[2,4],"Secondary", "Others")))


Gclusters1=filter(DF_kmeans, (Cluster== Centers[1,4] | Cluster== Centers[2,4] | Cluster== Centers[3,4])& Total_scene>=5 )%>%
  ggplot(aes(Total_scene, Total_lines, color=factor(Group), label= character)) +geom_point(alpha=0.7, stroke=0.5, size=3)+
  geom_text_repel(size=3)+
  scale_x_log10() +
  scale_y_log10()

x=filter(DF_kmeans, Cluster== Centers[1,4] | Cluster== Centers[2,4] )

```

From the kmean analysis obtain the following separation of characters:
  + *Main Characters*: As expected Rachel, Monica, Phoebe, Joey, Chandler and Ross constitue one group tha has that on average has 1,680 scenes, 8469 lines and 	87,498 words.
  + *Secondary Characters*: This group is composed by 33 characters, most of them are recurrent characters and guest stars. The average character in this group has on average 35 scenes, 133 lines and 	1,228 words.
  
  + *Other Characters*: composed for those characters that are incidental or did not have a relevant importance in the sitcom. The average character in this group has 2 scenes, 7 lines and 64 words.
  
Centers: 

```{r echo=FALSE}
Centers
```


```{r echo=FALSE}
ggplotly(Gclusters1)
```

* **Main characters participation**

Friends is a TV show that tells the story of a group of six friends: **Monica**, **Rachel**, **Phoebe**, **Chandler**, **Ross** and **Joey**.
Is one of these characters more important than others? We try to answer this question by looking at the number of lines for each of these main characters.

```{r echo=FALSE}
main_characters <- c("MONICA","RACHEL","PHOEBE","ROSS","CHANDLER","JOEY")

dialogues %>%
  filter(character %in% main_characters) %>%
  ggplot(aes(fct_infreq(character))) +
    geom_bar(fill="#0d1fe6") +
    ggtitle("Main characters lines count") +
    labs(x="character",y="lines count") +
    theme_bw()
```

We can see that Rachel is the character with more lines and Phoebe is the character with less lines.
Now we focus in the number of words instead of the number of lines.

```{r echo=FALSE}
dialogues %>%
  filter(character %in% main_characters) %>%
  group_by(character) %>%
  summarise(words_count=sum(words)) %>%
  ggplot(aes(x=reorder(character, -words_count),y=words_count)) +
    geom_col(fill="#0d1fe6") +
    ggtitle("Main characters words count") +
    labs(x="character",y="words count") +
    theme_bw()
```

Rachel and Ross are again the characters that speak the most and Phoebe the one with less words.
We can see that Monica was number 3 for number lines but she is number 5 for number of words. This suggests that Monica's lines tend to be shorter.
The opposite happens with Joey. He is number 5 for number of lines, but he is third for number of words. This suggests his lines tend to be longer.

```{r echo=FALSE}
dialogues %>%
  filter(character %in% main_characters) %>%
  group_by(character,episode_id) %>%
  summarise(lines_count=n()) %>%
  ggplot(aes(x=lines_count,y=..density..)) +
     geom_histogram(bins=40, color = "#0d1fe6", fill = "lightblue", boundary = 0) +
     geom_density(color = "#bd02da") +
     facet_wrap(~character) +
     theme_bw()
```

By looking into lines per episode distribution we find the following:
* Monica's distribution looks more narrow that the others. This indicates that there are few episodes in which Monica speaks a lot.
* Chandler and Ross have large right tails, we infer that those characters have episodes in which they speak a lot.
* Rachel and Ross have wider distributions.

### ***Unraveling the character interactions ***


For the Network analysis, a special data structure is required. We established a definition of interaction between characters when they share the same scene. We must mention that the original data structure of the dialogues does not permit us to identify the exact interaction of the characters in the scene. Hence, we have assumed that all the characters that appeared in every scene interacted between them. Moreover, we have assumed that the interactions between the characters will be represented by an adjacency matrix where we can observe the number of interactions that each character has with the others.

With the library [`igraph`](https://www.rdocumentation.org/packages/igraph/versions/1.2.4.2){target="_blank"}) we were able to create the adjecency matrix of the characters and quantify the interactions among the 869 characters. For the 6 main characters the adjacency matrix look like this:

```{r include=FALSE}

num_episode=as.data.frame(dialogues$episode_id[!duplicated(dialogues$episode_id)])
colnames(num_episode)[1]=c('episode_id')
Interaction=data.frame(from=character(), to=character(), episode=character(), scene=numeric(), stringsAsFactors=TRUE)


for (i in 1:nrow(num_episode)) 
{ 
  
  BD_episode=filter(dialogues,dialogues$episode_id==num_episode[i,])
  
  num_scene=as.data.frame(BD_episode$scene[!duplicated(BD_episode$scene)])
  
  colnames(num_scene)[1]=c('scene')
  
  for (j in 1:nrow(num_scene)) 
  {
    
    BD_scene=filter(BD_episode,BD_episode$scene==num_scene[j,])
    
    num_character=as.data.frame(BD_scene$character[!duplicated(BD_scene$character)])
    
    colnames(num_character)[1]=c('character')
    
    from=num_character %>% slice(rep(1:n(), each = n()))
    
    to=do.call("rbind", replicate(nrow(num_character), num_character, simplify = FALSE))
    
    episode_i=do.call("rbind", replicate(nrow(to), as.character(num_episode[i,]), simplify = FALSE))
    
    scene_i=do.call("rbind", replicate(nrow(to), num_scene[j,], simplify = FALSE))
    
    Interaction_i=data.frame(from, to, episode_i, scene_i )
    
    colnames(Interaction_i)=c('from','to','episode', 'scene')
    
    Interaction_i=subset(Interaction_i, from!=to)
    
    Interaction=rbind(Interaction,Interaction_i)
    
  }
  
  rm(Interaction_i,scene_i,episode_i,from, to, num_character, num_scene, BD_episode, BD_scene)
  
}

### 

G_Inter=graph_from_data_frame(Interaction, directed = FALSE, vertices = NULL)

Mat_Inter=as_adjacency_matrix(G_Inter, sparse=FALSE)

Mat_Inter=Mat_Inter/2

Mat_main=Mat_Inter[x[,1],x[,1]]

G_Inter_main=graph_from_adjacency_matrix(Mat_main, mode='undirected', weighted = TRUE)

data=toVisNetworkData(G_Inter_main)

nodes = inner_join(data$nodes,DF_kmeans[,c(1,5,6)], by=c("id"="character"))
colnames(nodes)[c(4)]=c('group')

edges=data$edges
edges$value=edges$weight

GNet=visNetwork(nodes, edges, height = "1000px", width="1000px") %>%
  visIgraphLayout(layout = "layout_in_circle")%>%
  visNodes(size = 10) %>%
  visOptions(selectedBy = "group",
             highlightNearest = list(enabled = TRUE, algorithm = "hierarchical", degree = 1),
             nodesIdSelection = TRUE)%>%
  visInteraction(hideEdgesOnDrag = TRUE)%>%
  visEdges(color = list(highlight = "blue", hover = "red"))%>%
  visGroups(groupname = "Main", color = "red", shape = "square", 
            shadow = list(enabled = TRUE))%>%
  visGroups(groupname = "Secondary", color = "blue", shape = "dot")

```

```{r echo=FALSE}
Mat_main[1:6, 1:6]
```

Also, we Can visualize iteractively the relationship between the Main and the Secondary Characters. The width of the graph represents the level of interactions among the characters, as you may percive the interactions between the main characters is very balance.
<font color="#960c0c"><i>Click and drag the vertices, or select the groups or the characters</i></font>
```{r echo=FALSE}
GNet
```

### ***Topic modelling using LDA***

For topic modelling we will use the package **textmineR**. We will try to find the topic for each episode. To do so we will create a document for each episode, so we have to group lines by episode_id.

```{r echo=FALSE}
dialogues_by_episode <- dialogues %>%
  group_by(episode_id) %>%
  summarise(lines=trimws(paste(line, collapse = " ")))
head(dialogues_by_episode)
```

Function CrateDtm creates a document term matrix. To do so we use a group of stopwords, words we don't want to use because they are used frequently in English language and do not give insightful information.

```{r echo=FALSE}
#create DTM
set.seed(12345)
dtm <- CreateDtm(dialogues_by_episode$lines,
                 doc_names = dialogues_by_episode$episode_id,
                 stopword_vec = c(stopwords::stopwords("en"),
                                  stopwords::stopwords(source = "smart"),
                                  tolower(main_characters),
                                  c("yeah","uh","ah","ya","umm","ow","hey","um","huh",
                                    "uhm","gonna","wanna","ohh","ooh","mr","ahh","whoa",
                                    "la","ha","ugh","woah","alright")),
                 ngram_window = c(1, 2))
dtm <- dtm[,colSums(dtm) > 2]
```

We will use document term matrix to create a Term Document Frequency matrix that counts the number of times a term appears (term frequency) and the number of documents in which a term appears (document frequency).

These are the main terms ordered by term frequency:

```{r echo=FALSE }

tf <- TermDocFreq(dtm = dtm)
original_tf <- tf %>% select(term, term_freq,doc_freq)
rownames(original_tf) <- 1:nrow(original_tf)
head( original_tf[ order(original_tf$term_freq, decreasing=TRUE), ] )
```

Now we fit a Latent Dirichlet allocation model in which we will try to fit 15 topics into the collection of episodes. This will return to main matrices:

* **theta**: Matrix with the probability of topic per document -> P(topic | document).
* **phi**: Matrix with the probability of term per topic -> P(term | topic).

```{r echo=FALSE}
set.seed(12345)
model <- FitLdaModel(dtm = dtm,
                     k = 15,
                     iterations = 1000,
                     burnin = 180,
                     alpha = 0.1,
                     beta = 0.05,
                     optimize_alpha = TRUE,
                     calc_likelihood = TRUE,
                     calc_coherence = TRUE,
                     calc_r2 = TRUE,
                     cpus = 2)

print("Theta:")
head(model$theta[,1:5])
print("Phi:")
head(model$phi[,1:5])
```

Now the 15 topics have been created. To know about the topics quality we look into the **topic coherence**, this is a measure of how associated are words in a topic.

```{r echo=FALSE}
summary(model$coherence)

hist(model$coherence,
     col= "#0d1fe6",
     main = "Histogram of topic coherence")
```

We will use phi to get the top 5 terms per topic.

```{r echo=FALSE}
model$top_terms <- GetTopTerms(phi = model$phi, M = 5)
t(model$top_terms)
```

The next step is to compute the topic prevalence using theta. Topic prevalence indicate the most frequent topics in the TV show.

```{r echo=FALSE}
model$prevalence <- colSums(model$theta) / sum(model$theta) * 100

ggplot() +
  geom_point(aes(x=model$prevalence,y=model$alpha), color = "#0d1fe6")+
    ggtitle("Topic prevalence") +
    labs(x="prevalence",y="alpha") +
    theme_bw()

```

Finally, we get a summary for the complete LDA model.

```{r echo=FALSE}

model$summary <- data.frame(topic = rownames(model$phi),
                            coherence = round(model$coherence, 3),
                            prevalence = round(model$prevalence,3),
                            top_terms = apply(model$top_terms, 2, function(x){
                              paste(x, collapse = ", ")
                            }),
                            stringsAsFactors = FALSE)

model$summary[ order(model$summary$prevalence, decreasing = TRUE) , ]
```

We can see that the most prevalent (frequent) topic has words like "good", "god","great", "time". This makes sense, this words are very frequent in the TV show and that is why they give very little information about the topic. That is why the coherence is 0.0.

The other topics in the model have less prevalence but they are more coherent. If you are a fan of the show and if you read the list of top terms, we are sure you can remember episodes in which those terms were important.

To find those important episodes we created a d3 tool. We wrote a csv file using theta in which, for each episode and topic we put the probability of that topic given the episode and the top terms of that topic.

```{r echo=FALSE}
assignments <- rownames_to_column(as.data.frame(t(model$theta)),var="rowID") %>%
  gather(key="topic",value="value",-rowID) %>%
  rename(topic2=topic) %>%
  rename(rowID2=rowID) %>%
  rename(topic=rowID2) %>%
  rename(id=topic2) %>%
  mutate(topic_num=  as.integer(substr(topic,3,1000000)) )

assignments2 <- merge(x = assignments, y = model$summary[,c("topic","top_terms")], by = "topic", all.x = TRUE)
assignments3 <- merge(x = assignments2, y = episodes_df[,c("id","name")], by = "id", all.x = TRUE)

head(assignments3)
write.csv(assignments3,"data/topics_assignments.csv")
```


```{r echo=FALSE}
htmltools::includeHTML("./docs/d3_lda.html")
```

### ***Features driving the rating***

To look for the main features that drive the rating up or down, it is useful to start by observing its tempral structure. The following graph is **interactive**:

<font color="#960c0c"><i>Click on the season title to (de)activate each series</i></font>

```{r echo=FALSE}
htmltools::includeHTML('./docs/rating_per_season.html')
```

  - There is a generalized behaviour among the 10 seasons:
    - Episode 1 has high rating and immediately falls into a valley around 8.4
    - Through episodes 6-9 theres usually a peak followed of another (larger) valley
    - Finally, the last episode has high rating

Next, to create a cleaner view of the data, we create a boxplot

```{r echo=FALSE}
load('./data/dfepisode.RData')
load('./data/dfratings.RData')

key <- function(season, episode){
  # s <- toString(season)
  e <- str_pad(episode, 2, 'left', 0)
  paste(season, e, sep=' : ')
}

episode <- dfepisode %>%
  filter(parentTconst=='tt0108778')  %>%
  mutate(key = key(seasonNumber, episodeNumber),
         episodeNumber = as.integer(as.character(episodeNumber)),
         seasonNumber = factor(seasonNumber, levels = 1:10)) %>%
  left_join(dfratings, by = 'tconst') %>%
  arrange(as.numeric(as.character(seasonNumber)), as.numeric(as.character(episodeNumber)))

ggplot(episode, aes(x=factor(episodeNumber, levels = 1:25), averageRating)) + geom_boxplot()
```

 The boxplots not only help to confirm in a cleaner graph the behaviour observed previously, but also provides additional insigths like:
 
  - The perceived quality (in terms of rating) of episodes 7 to 9 varies a lot from season to season.
  - The 10th episode for all season has low rating surrounding 8.2. These were traditionally aired through the holidays season in December.
  - Two highest ratings:
    - Special episode after the 1996 Super Bowl
    - Final episode (Season 10, episode 18)
  - Two lowest ratings ():
    - Season 10, episode 10: "Christmas in Tulsa"
    - Season 6, episode 20: "Mac and Cheese" happens in the 19-21 episode valley

A likely explanation for the behaviour on the last 7 episodes of all seasons is that writers may have prepared some intricated plot (an not necessarily amusing) to be climaxed on the lasts episodes.

## **VI. Interactive component**

We included four elements that are interactive:

* **Zoom scatterplor** using plotly.
* **Interaction network** using VisNetwork.
* **Bar plot for topics per episode** using d3.
* **Rating timeseries per season** using d3.


## **VII. Conclusion**

* Rachel and Ross are the characters with most lines, this suggests that most of the stories go arround them.
* Using K-means we could find 3 clear groups of characters, that match with the roles that the character play in the TV show.
* Using VisNetwork we could build a tool that allows the user to explore the interaction between characters, depending on characters that shared scenes.
* The most frequent terms found in the topic modelling tell us that Friends is a TV show with a very simple language. Words like "Good", "Great", "alright" and "guys" are arround the most common.
* Topic modelling results are not clear, but we do can tag some episodes in four categories "weddings", "baby-doctor", "party-thanksgiving" and "work".

